#include "sh1106.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <string.h>


static const char *TAG = "SH1106";

// Simple 8x8 font (ASCII 32-127)
static const uint8_t font_8x8[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00}, // )
    {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // ;
    {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // <
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00}, // =
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00}, // Z
    {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00}, // [
    {0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00}, // backslash
    {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00}, // ]
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00}, // ^
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // _
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00}, // `
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00}, // a
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // b
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00}, // c
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00}, // d
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00}, // e
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00}, // f
    {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00, 0x00, 0x00}, // g
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // h
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00}, // i
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00}, // j
    {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00}, // k
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // l
    {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, 0x00}, // m
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // n
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // o
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00}, // p
    {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00}, // q
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00}, // r
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00}, // s
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00}, // t
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00}, // u
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00}, // v
    {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00}, // w
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // x
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00}, // y
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00}, // z
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00}, // {
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00}, // |
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00}, // }
    {0x10, 0x08, 0x08, 0x10, 0x08, 0x00, 0x00, 0x00}, // ~
};

static esp_err_t sh1106_write_command(sh1106_handle_t *handle, uint8_t cmd) {
  uint8_t data[2] = {0x00, cmd}; // 0x00 = command mode

  i2c_cmd_handle_t i2c_cmd = i2c_cmd_link_create();
  i2c_master_start(i2c_cmd);
  i2c_master_write_byte(i2c_cmd, (handle->i2c_address << 1) | I2C_MASTER_WRITE,
                        true);
  i2c_master_write(i2c_cmd, data, 2, true);
  i2c_master_stop(i2c_cmd);

  esp_err_t ret = i2c_master_cmd_begin(handle->i2c_port, i2c_cmd,
                                       pdMS_TO_TICKS(SH1106_I2C_TIMEOUT_MS));
  i2c_cmd_link_delete(i2c_cmd);

  return ret;
}

static esp_err_t sh1106_write_data(sh1106_handle_t *handle, uint8_t *data,
                                   size_t len) {
  i2c_cmd_handle_t i2c_cmd = i2c_cmd_link_create();
  i2c_master_start(i2c_cmd);
  i2c_master_write_byte(i2c_cmd, (handle->i2c_address << 1) | I2C_MASTER_WRITE,
                        true);
  i2c_master_write_byte(i2c_cmd, 0x40, true); // 0x40 = data mode
  i2c_master_write(i2c_cmd, data, len, true);
  i2c_master_stop(i2c_cmd);

  esp_err_t ret = i2c_master_cmd_begin(handle->i2c_port, i2c_cmd,
                                       pdMS_TO_TICKS(SH1106_I2C_TIMEOUT_MS));
  i2c_cmd_link_delete(i2c_cmd);

  return ret;
}

esp_err_t sh1106_init(sh1106_handle_t *handle, i2c_port_t i2c_port,
                      gpio_num_t sda_pin, gpio_num_t scl_pin,
                      uint32_t i2c_freq) {
  esp_err_t ret;

  // Configure I2C
  i2c_config_t conf = {
      .mode = I2C_MODE_MASTER,
      .sda_io_num = sda_pin,
      .scl_io_num = scl_pin,
      .sda_pullup_en = GPIO_PULLUP_ENABLE,
      .scl_pullup_en = GPIO_PULLUP_ENABLE,
      .master.clk_speed = i2c_freq,
  };

  ret = i2c_param_config(i2c_port, &conf);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "I2C param config failed");
    return ret;
  }

  ret = i2c_driver_install(i2c_port, conf.mode, 0, 0, 0);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "I2C driver install failed");
    return ret;
  }

  handle->i2c_port = i2c_port;
  handle->i2c_address = SH1106_I2C_ADDRESS;

  // Initialize display
  vTaskDelay(pdMS_TO_TICKS(100)); // Wait for display to power up

  sh1106_write_command(handle, SH1106_CMD_DISPLAY_OFF);
  sh1106_write_command(handle, SH1106_CMD_SET_CLOCK_DIV);
  sh1106_write_command(handle, 0x80);
  sh1106_write_command(handle, SH1106_CMD_SET_MULTIPLEX);
  sh1106_write_command(handle, 0x3F);
  sh1106_write_command(handle, SH1106_CMD_SET_DISPLAY_OFFSET);
  sh1106_write_command(handle, 0x00);
  sh1106_write_command(handle, 0x40); // Set start line
  sh1106_write_command(handle, SH1106_CMD_SET_CHARGE_PUMP);
  sh1106_write_command(handle, 0x14); // Enable charge pump
  sh1106_write_command(handle, SH1106_CMD_SET_SEGMENT_REMAP);
  sh1106_write_command(handle, SH1106_CMD_SET_SCAN_DIRECTION);
  sh1106_write_command(handle, SH1106_CMD_SET_COM_PINS);
  sh1106_write_command(handle, 0x12);
  sh1106_write_command(handle, SH1106_CMD_SET_CONTRAST);
  sh1106_write_command(handle, 0xCF);
  sh1106_write_command(handle, SH1106_CMD_SET_PRECHARGE);
  sh1106_write_command(handle, 0xF1);
  sh1106_write_command(handle, SH1106_CMD_SET_VCOM_DESELECT);
  sh1106_write_command(handle, 0x40);
  sh1106_write_command(handle, 0xA4); // Display RAM content
  sh1106_write_command(handle, 0xA6); // Normal display (not inverted)
  sh1106_write_command(handle, SH1106_CMD_DISPLAY_ON);

  // Clear buffer
  memset(handle->buffer, 0, sizeof(handle->buffer));

  ESP_LOGI(TAG, "SH1106 initialized successfully");
  return ESP_OK;
}

esp_err_t sh1106_clear_display(sh1106_handle_t *handle) {
  memset(handle->buffer, 0, sizeof(handle->buffer));
  return sh1106_update_display(handle);
}

esp_err_t sh1106_clear_section(sh1106_handle_t *handle,
                               sh1106_section_t section) {
  uint8_t start_page, num_pages;

  switch (section) {
  case SECTION_HEADER:
    start_page = 0;
    num_pages = 3; // Pages 0-2
    break;
  case SECTION_BODY:
    start_page = 3;
    num_pages = 3; // Pages 3-5
    break;
  case SECTION_FOOTER:
    start_page = 6;
    num_pages = 2; // Pages 6-7
    break;
  default:
    return ESP_ERR_INVALID_ARG;
  }

  for (uint8_t page = start_page; page < start_page + num_pages; page++) {
    memset(handle->buffer[page], 0, SH1106_WIDTH);
  }

  return ESP_OK;
}

esp_err_t sh1106_write_text_offset(sh1106_handle_t *handle,
                                   sh1106_section_t section, const char *text,
                                   uint8_t x, uint8_t y, uint8_t v_offset) {
  uint8_t start_page;

  switch (section) {
  case SECTION_HEADER:
    start_page = 0; // Pages 0-2
    break;
  case SECTION_BODY:
    start_page = 3; // Pages 3-5
    break;
  case SECTION_FOOTER:
    start_page = 6; // Pages 6-7
    break;
  default:
    return ESP_ERR_INVALID_ARG;
  }

  // Limit vertical offset to prevent overflow
  if (v_offset > 7) {
    v_offset = 7;
  }

  uint8_t page = start_page + y;
  uint8_t col = x;

  for (size_t i = 0; text[i] != '\0' && col < SH1106_WIDTH; i++) {
    uint8_t c = text[i];
    if (c >= 32 && c <= 126) {
      // Copy font character to buffer with vertical offset
      for (uint8_t j = 0; j < 8 && col < SH1106_WIDTH; j++) {
        // Shift the font data down by v_offset pixels
        uint8_t font_data = font_8x8[c - 32][j];

        if (v_offset > 0) {
          // Split across two pages if offset is used
          uint8_t upper_bits = font_data << v_offset;
          uint8_t lower_bits = font_data >> (8 - v_offset);

          handle->buffer[page][col] |= upper_bits;
          if (page + 1 < SH1106_PAGES) {
            handle->buffer[page + 1][col] |= lower_bits;
          }
        } else {
          handle->buffer[page][col] = font_data;
        }
        col++;
      }
    }
  }

  return ESP_OK;
}

esp_err_t sh1106_write_text(sh1106_handle_t *handle, sh1106_section_t section,
                            const char *text, uint8_t x, uint8_t y) {
  return sh1106_write_text_offset(handle, section, text, x, y, 0);
}

esp_err_t sh1106_update_display(sh1106_handle_t *handle) {
  for (uint8_t page = 0; page < SH1106_PAGES; page++) {
    // Set page address
    sh1106_write_command(handle, SH1106_CMD_SET_PAGE_ADDR | page);

    // Set column address (SH1106 has 132 columns, display starts at column 2)
    sh1106_write_command(handle, SH1106_CMD_SET_LOW_COLUMN | 0x02);
    sh1106_write_command(handle, SH1106_CMD_SET_HIGH_COLUMN | 0x00);

    // Write page data
    sh1106_write_data(handle, handle->buffer[page], SH1106_WIDTH);
  }

  return ESP_OK;
}

esp_err_t sh1106_set_contrast(sh1106_handle_t *handle, uint8_t contrast) {
  sh1106_write_command(handle, SH1106_CMD_SET_CONTRAST);
  sh1106_write_command(handle, contrast);
  return ESP_OK;
}